access_by_lua_block {
    local http = require("resty.http")
    local cjson = require("cjson.safe")
    local b64 = require("ngx.base64")

    local httpc = http.new()

    local keycloak_auth_url = os.getenv("KEYCLOAK_AUTH_URL")
    local keycloak_realm = os.getenv("KEYCLOAK_AUTH_REALM")
    local client_id = os.getenv("KEYCLOAK_CLIENT_ID")
    local client_secret = os.getenv("KEYCLOAK_CLIENT_SECRET")

    local token_url = keycloak_auth_url .. "/realms/" .. keycloak_realm .. "/protocol/openid-connect/token"
    local introspect_url = keycloak_auth_url .. "/realms/" .. keycloak_realm .. "/protocol/openid-connect/token/introspect"

    local headers = ngx.req.get_headers()
    local auth_header = headers["Authorization"]
    local access_token
    -- Retrieve stored refresh token from cookie if present
    local refresh_token = ngx.var.cookie_REFRESH_TOKEN

    -- Check if a bearer token was provided
    if auth_header and auth_header:find("Bearer ") then
        access_token = auth_header:sub(8)

        -- Validate the token
        local res, err = httpc:request_uri(introspect_url, {
            method = "POST",
            body = ngx.encode_args({
                token = access_token,
                client_id = client_id,
                client_secret = client_secret
            }),
            headers = { ["Content-Type"] = "application/x-www-form-urlencoded" },
            ssl_verify = false
        })

        if res then
            local token_data = cjson.decode(res.body)
            if token_data and token_data.active then
                ngx.log(ngx.INFO, "Valid access token, request allowed")
                ngx.req.set_header("Authorization", "Bearer " .. access_token)
                return
            else
                ngx.log(ngx.WARN, "Access token is expired or invalid")
            end
        else
            ngx.log(ngx.ERR, "Access token validation request failed: " .. (err or "unknown error"))
        end
    end

    -- Attempt to refresh the token if a refresh token is available
    if refresh_token then
        local res, err = httpc:request_uri(token_url, {
            method = "POST",
            body = ngx.encode_args({
                grant_type = "refresh_token",
                client_id = client_id,
                client_secret = client_secret,
                refresh_token = refresh_token
            }),
            headers = { ["Content-Type"] = "application/x-www-form-urlencoded" },
            ssl_verify = false
        })

        if res then
            httpc:set_keepalive(60000, 10)
            local token_response = cjson.decode(res.body)
            if token_response and token_response.access_token then
                ngx.log(ngx.INFO, "Access token refreshed, request allowed")
                ngx.req.set_header("Authorization", "Bearer " .. token_response.access_token)
                -- Store new refresh token (if provided)
                if token_response.refresh_token then
                    ngx.header["Set-Cookie"] = "REFRESH_TOKEN=" .. token_response.refresh_token .. "; Path=/; HttpOnly; Secure"
                else
                    ngx.log(ngx.WARN, "No new refresh token received from provider")
                end
                return
            else
                ngx.log(ngx.WARN, "Access token refresh failed, falling back to Basic Authentication")
            end
        else
            ngx.log(ngx.ERR, "Error refreshing access token: " .. (err or "unknown error"))
        end
    end

    -- If bearer authentication fails, fall back to Basic Auth
    if not auth_header or not auth_header:find("Basic ") then
        ngx.header["WWW-Authenticate"] = 'Basic realm="Restricted"'
        ngx.log(ngx.ERR, "Authorization Basic header not found")
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end
    local decoded = b64.decode_base64url(auth_header:sub(7))
    local username, password = decoded:match("([^:]+):(.+)")
    if not username or not password then
        ngx.log(ngx.ERR, "Authorization Basic credential(s) not found")
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end

    -- Request access & refresh token using password grant
    local res, err = httpc:request_uri(token_url, {
        method = "POST",
        body = ngx.encode_args({
            grant_type = "password",
            client_id = client_id,
            client_secret = client_secret,
            username = username,
            password = password
        }),
        headers = { ["Content-Type"] = "application/x-www-form-urlencoded" },
        ssl_verify = false
    })

    if not res then
        ngx.log(ngx.ERR, "Error requesting access token: " .. (err or "unknown error"))
        ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
    end

    httpc:set_keepalive(60000, 10)

    local token_response = cjson.decode(res.body)
    if not token_response or not token_response.access_token then
        ngx.log(ngx.ERR, "Failed to get access token: " .. (res.body or "No response body"))
        ngx.exit(ngx.HTTP_UNAUTHORIZED)
    end
    ngx.log(ngx.INFO, "Basic Authentication successful")

    -- Store refresh token in HTTP-only cookie
    if token_response.refresh_token then
        ngx.header["Set-Cookie"] = "REFRESH_TOKEN=" .. token_response.refresh_token .. "; Path=/; HttpOnly; Secure"
    else
        ngx.log(ngx.WARN, "No new refresh token received from provider")
    end

    -- Set user headers
    ngx.req.set_header("X-Remote-User", username)
    ngx.req.set_header("X-Forwarded-User", username)
    ngx.req.set_header("Authorization", "Bearer " .. token_response.access_token)
}